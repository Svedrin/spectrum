#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys, os
from configobj import ConfigObj
from optparser import OptParser
import signal
import subprocess

# - commands --------------------------

def stats(jid, passwd, host):
    from twisted.internet import reactor, task
    from twisted.internet import reactor
    from twisted.names.srvconnect import SRVConnector
    from twisted.words.xish import domish
    from twisted.words.protocols.jabber import xmlstream, client, jid
    from twisted.words.protocols.jabber.client import IQ

    class XMPPClientConnector(SRVConnector):
        def __init__(self, reactor, domain, factory):
            SRVConnector.__init__(self, reactor, 'xmpp-client', domain, factory)

        def pickServer(self):
            #host, port = SRVConnector.pickServer(self)

            if not self.servers and not self.orderedServers:
                # no SRV record, fall back..
                port = 5222

            return self.servers[0], self.servers[1]

    class Client(object):
        def __init__(self, client_jid, secret):
            self.jid = client_jid
            self.password = secret
            self.f = client.basicClientFactory(client_jid, secret)
            self.f.addBootstrap(xmlstream.STREAM_CONNECTED_EVENT, self.connected)
            self.f.addBootstrap(xmlstream.STREAM_END_EVENT, self.disconnected)
            self.f.addBootstrap(xmlstream.STREAM_AUTHD_EVENT, self.authenticated)
            connector = XMPPClientConnector(reactor, client_jid.host, self.f)
            connector.servers = [self.jid.host, 5222]
            connector.orderedServers = [self.jid.host, 5222]
            connector.connect()
            self.t = reactor.callLater(10, self.failed)

        def failed(self):
            reactor.stop()

        def rawDataIn(self, buf):
            #msg = "RECV: {0}\n".format(unicode(buf, 'utf-8').encode('ascii', 'replace'))
            #self.logs += msg
            #print msg
            pass

        def rawDataOut(self, buf):
            #msg = "SEND: {0}\n".format(unicode(buf, 'utf-8').encode('ascii', 'replace'))
            #self.logs += msg
            #print msg
            pass

        def connected(self, xs):
            self.xmlstream = xs

            # Log all traffic
            xs.rawDataInFn = self.rawDataIn
            xs.rawDataOutFn = self.rawDataOut

        def disconnected(self, xs):
            pass

        def authenticated(self, xs):
            self.getStats(sys.argv[3])

        def getStats(self, jid = "icq.netlab.cz"):
            iq = IQ(self.xmlstream, "get")
            iq['to'] = jid
            iq.addElement(("http://jabber.org/protocol/stats", "query"))

            iq.addCallback(self._statsReceived)
            iq.send()
        
        def _statsReceived(self, el):
            iq = IQ(self.xmlstream, "get")
            iq['to'] = el['from']
            q = iq.addElement(("http://jabber.org/protocol/stats", "query"))

            query = el.firstChildElement()
            for child in query.children:
                s = q.addElement('stat')
                s['name'] = child['name']

            iq.addCallback(self._statsDataReceived)
            iq.send()

        def _statsDataReceived(self, el):
            query = el.firstChildElement()
            for stat in query.elements():
                print stat['name'].replace('/', '_').replace('-',  '_'),stat['value'],stat["units"]
            reactor.stop()

    Client(jid.JID(jid + "/stats"), passwd)
    reactor.run()

# ------------------------------------- 

def get_config(filename):
    if not os.path.exists(filename):
        if not filename.endswith(".cfg"):
            filename += ".cfg"
        default_location = os.path.join("/etc/spectrum", filename) 
        if os.path.exists(default_location):
            filename = default_location

    if not os.path.exists(filename):
        print "Config file", filename, "does not exist."
        exit(1)
    
    return ConfigObj(filename)
    
def get_pid(config):
    if config['service'].has_key("pid_file"):
        pid_file = config['service']['pid_file'].replace("$jid", config['service']['jid'])
    else:
        pid_file = os.path.join("/var/run/spectrum", config['service']['jid'])

    if not os.path.exists(pid_file):
        return pid_file, None

    return pid_file, int(file.read(pid_file).strip())

def start_daemon(config):
    if get_pid(config)[1]:
        print "There is already running spectrum instance for this jid, ",
        print "please stop this instance first"
        exit(1)

    print "Starting spectrum instance for jid", config['service']['jid']
    spectrum_here = os.path.join(os.getcwd(), "spectrum")
    if os.path.exists(spectrum_here):
        subprocess.call((spectrum_here, sys.argv[1]))
    else:
        subprocess.call(("spectrum", filename))
    print "Started"

def stop_daemon(config):
    pid_file, pid = get_pid(config)
    
    if pid is None:
        print "There is no running instance for jid", config['service']['jid']
        exit(1)

    print "Stopping {jid} ({pid_file}) ({pid})".format(
        jid=config['service']['jid'],
        pid_file=pid_file,
        pid=pid)

    os.remove(pid_file)
    os.kill(pid, signal.SIGTERM)
    print "Stopped"

def main():
    usage = """usage:
    %prog <config file> start
    %prog <config file> stop
    % <bare JID> <password> <transport hostname> <command> [args...]
    Commands list :
        stats - show transport statistics
    """
    parser = OptionParser(usage)
    #parser.add_option("-v", "--verbose",
    #                  action="store_true", dest="verbose")
    (options, args) = parser.parse_args()

    #if options.verbose:
    #    print "reading {0}...".format(args[0])
        
    commands = dict(stats=stats)
    
    config = get_config(args[0])
    if args[1] == 'start':
        start_daemon(config)
    elif args[1] == 'stop':
        stop_daemon(config)
    elif args[3] in commands:
        commands[args[3]](args[0], args[1], args[2])
    else:
        print 'No such command: ', args[3]
        exit(1)

if __name__ == "__main__":
    main()
