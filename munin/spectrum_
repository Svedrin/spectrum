#!/usr/bin/python -Wignore::DeprecationWarning
# -*- coding: utf-8 -*-
#
# Wildcard-plugin to monitor spectrum transport usage through an XMPP-connection
# sending Statistics Gathering (XEP-0039 [1]) packets. Depending on the suffix,
# the plugin monitors one specific characteristic of one or more spectrum
# instances.
#
# Current suffixes are:
#     spectrum_uptime (monitor uptime of transports)
#     spectrum_registered (how many users are registered to the transport)
#     spectrum_online (how many users are online)
#     spectrum_legacy_registered
#     spectrum_legacy_online (same as above, only for the legacy network)
#     spectrum_messages (how many messages have been sent over this transport)
#     spectrum_memory (how much memory the transport consumes)
#
# Configuration:
#     You need to configure this plugin (just like any other plugin) in
#	     plugin-conf.d/munin-node.
#     You have to configure the plugin to run as user and group "spectrum".
#
#     By default, the plugin monitors all instances configured in a config-file
#     in /etc/spectrum. If you use a different directory, you can specify the
#     environment-variable "base". If you do not want to monitor all instances,
#     you can give an explicit listing of the corresponding configuration files
#     with the environment variable "cfgs".
#     
#     Here is an example of a configuration. Note again that you can ommit both
#     env.cfgs and env.base:
#
#     [spectrum_*]
#     user spectrum
#     group spectrum
#     env.cfgs xmpp.example.com.cfg,irc.example.com.cfg
#     env.base /etc/spectrum
#
# Author:
#     Mathias Ertl <mati@fsinf.at>
# 
# Changelog:
#     2.0: Port to config_interface local socket
#     1.1: Suffixes that aggregate multiple values no longer show the individual
#     	values by default. This can be overridden by setting the "verbose"
#     	env-variable to any non-empty string.
#     1.0: Initial version
#
# [1] http://xmpp.org/extensions/xep-0039.html
#
# Copyright (c) 2009 Mathias Ertl.
#
# Permission to use, copy, and modify this software with or without fee
# is hereby granted, provided that this entire notice is included in
# all source code copies of any software which is or includes a copy or
# modification of this software.
#
# THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
# IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
# REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
# MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
# PURPOSE.
#
# Magic markers
#%# family=auto
#%# capabilities=autoconf suggest

import sys
# autoconf and suggest handling:
if len( sys.argv ) > 1:
	if sys.argv[1] == 'autoconf':
		try:
			import xmpp
		except ImportError:
			print( 'no (no xmpp library found)' )
			sys.exit(1)
		print( 'yes' )
		sys.exit( 0 )
	elif sys.argv[1] == 'suggest':
		print( """uptime
registered
online
legacy_registered
legacy_online
messages
messages_sec
memory""" )
		sys.exit(0)

import os, xmpp, socket, re, ConfigParser
from spectrum import * 

# filter forbidden characters for munin fieldnames
def handle_field( string ):
	for regexp in [ '^[^A-Za-z_]', '[^A-Za-z0-9_]' ]:
		string = re.compile( regexp ).sub( '_', string )
	return string

# get runtime variables
suffix = sys.argv[0].partition('_')[2]
verbose = os.environ.get( 'verbose' )
base = os.environ.get( 'base', '/etc/spectrum' )
cfgs = os.environ.get( 'cfgs', ','.join( os.listdir( base ) ) )

# set variables based on wildcard 
if suffix == 'uptime':
	stat = [ 'uptime' ]
	title = "Uptime"
	vlabel = "days"
	transformer = lambda value: float(value)/60.0/60.0/24.0
elif suffix == 'registered':
	stat = [ 'users/registered' ]
	title = "Registered users"
	vlabel = "users"
elif suffix == 'online':
	stat = [ 'users/online' ]
	title = "Online users"
	vlabel = "users"
elif suffix == 'legacy_registered':
	stat = [ 'legacy-network-users/registered' ]
	title = "Buddies online"
	vlabel = "users"
elif suffix == 'legacy_online':
	stat = [ 'legacy-network-users/online' ]
	title = "Buddies in roster (total)"
	vlabel = "users"
elif suffix == 'messages':
	stat = [ 'messages/in', 'messages/out' ]
	suffixes = [ 'in', 'out' ]
	title = "Messages send over transport"
	vlabel = "messages"
elif suffix == 'messages_sec':
	stat = [ 'messages/in', 'messages/out' ]
	suffixes = [ 'in', 'out' ]
	title = "Messages send over transport per second"
	vlabel = "messages/sec"
elif suffix == 'memory':
	stat = [ 'memory-usage' ]
	title = "Memory usage of transports"
	vlabel = "megabytes"
	transformer = lambda value: float(value)/1024.0

# handle config
if len( sys.argv ) > 1 and  sys.argv[1] == 'config':
	print( """graph_title %s
graph_args --base 1000 -l 0
graph_scale no
graph_vlabel %s
graph_category transports""" %(title, vlabel) )
	for cfg in cfgs.split( ',' ):
		path = cfg.strip()
		if not os.path.isabs( path ):
			path = os.path.normpath( base + '/' + path )

		config = spectrumconfigparser.SpectrumConfigParser()
		config.read( path )
		jid = config.get( 'service', 'jid' )

		if len(stat) > 1:
			label = jid + ' total'
			fieldname = handle_field( label )
			print( '%s.label %s' %(fieldname, label) )
			if suffix == 'messages_sec':
				print( '%s.type DERIVE' %(fieldname) )

			# to not print individual fields if verbose is not set:
			if not verbose: 
				continue

		for i in range(0, len(stat)):
			line = stat[i]
			label = jid
			if 'suffixes' in globals():
				label += ' ' + suffixes[i]
			fieldname = handle_field( label )
			print( '%s.label %s' %(fieldname, label) )
			if suffix == 'messages_sec':
				print( '%s.type DERIVE' %(fieldname) )
	sys.exit(0)

# callback to handle incoming packets
def handler_fetch( packet ):
	jid = str( packet.getFrom() )
	total = None

	children = [ child for child in packet.getChildren()[0].getChildren()
		if child.getAttr('name') in stat ] # google list-comprehension
	for child in children:
		label = jid
		value = child.getAttr( 'value' )
		if len( stat ) > 1:
			i = stat.index( child.getAttr( 'name' ) )
			suffix = suffixes[i]
			label += ' ' + suffix
			if total == None:
				total = int( value )
			else:
				total += int( value )
			if not verbose:
				continue
			
		fieldname = handle_field( label )
		if 'transformer' in globals():
			value = transformer(value)

		print( '%s.value %s' %(fieldname, value) )

	if total != None:
		fieldname = handle_field( jid + ' total' )
		if 'transformer' in globals():
			total = transformer( total )
		print( '%s.value %s' %(fieldname, total) )

# form basic package:
pkg = xmpp.Iq( typ='get', queryNS='http://jabber.org/protocol/stats' )
for name in [ 'uptime', 'users/registered', 'users/online',
		'legacy-network-users/online',
		'legacy-network-users/registered',
		'messages/in', 'messages/out',
		'memory-usage' ]:
	child = xmpp.simplexml.Node( 'stat', {'name': name} )
	pkg.kids[0].addChild( node=child )

for cfg in cfgs.split( ',' ):
	path = cfg
	if not os.path.isabs( path ):
		path = base + '/' + path

	config = spectrumconfigparser.SpectrumConfigParser()
	config.read( path )
	pkg.setTo( config.get( 'service', 'jid' ) )

	try:
		# send and receive via local socket:
		config_interface = config.get( 'service', 'config_interface' )
		s = socket.socket( socket.AF_UNIX )
		s.settimeout( 3.0 )
		s.connect( config_interface )
		s.send( str( pkg ) )
		data = s.recv( 10240 )
		s.close()

		# parse data received via socket:
		node = xmpp.protocol.Iq( node=xmpp.simplexml.XML2Node( data ) )
		handler_fetch( node )
	except ConfigParser.NoOptionError, e:
		print( 'Error: %s: %s' %(path, e) )
	except socket.error, msg:
		print( 'Error: %s: %s' %(config_interface, msg.strerror ) )
